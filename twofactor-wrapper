#!/usr/bin/expect

if { [array names env TWOFACTOR_SECRET_PATH] != "" } {
	set expanded_secret_path [glob $env(TWOFACTOR_SECRET_PATH)]
	set secret [exec sed -n /^secret=/s///p $expanded_secret_path]
} else {
	set secret $env(TWOFACTOR_SECRET)
}

set token [exec oathtool --totp --base32 $secret]

log_user 0

# Non-blocking mode on stdin makes this not choke on certain datasets and/or
# network environments. I'm not sure what the root cause, but copious
# flailing led to this empirical evidence. :-) While we're in here, we'll
# make stdout non-blocking too, as a hedge.
fconfigure stdin -blocking 0
fconfigure stdout -blocking 0

stty raw
stty -echo
# LogLevel=QUIET suppresses ssh's 'Connection to HOST closed.' output.
spawn -noecho -nottyinit ssh -o LogLevel=QUIET \
	-o NumberOfPasswordPrompts=1 -o StrictHostKeyChecking=no {*}$argv
stty -raw
stty echo

expect {
	-re "\[Pp\]assword:\\s*" {
		send "$env(TWOFACTOR_PASSWORD)\n"
		exp_continue
	} -re "Verification code:\\s*" {
		send "$token\n"
		expect "\n"
	}
}

interact
catch wait result
exit [lindex $result 3]
